# Functional Requirements #
> ## Gameplay ##
> The game is played level-by-level with the furthest level completed being remembered by the system, allowing every level up to that one being accessible from the main menu henceforth.

> Levels are based on a 2D grid in which tools may be placed to achieve the goals. A level is completed by lighting up every receptor goal by a light beam of its respective color. Levels may be of arbitrary dimensions with any number of emitters and receptors. There may be obstacles built into the level which block light beams.

> Light beams may be white, red, green, or blue. White light may be split with a prism tool into the separate colors, which always each leave at the same angles respective to the incoming white light beam. The beams are guided by placing mirror tools onto the grid which will bounce light toward a different direction.

> Each tool has a limited stock quantity allowed to be placed which varies by level. Emitters and mirrors may be rotated by a double-tap input. Misplaced tools may be erased with the eraser tool.

> The camera is moved by swiping the screen for translation and two-finger pinching for zooming. All controls are accessible through the touch-screen.

> ## Fun factor ##
> Perhaps an obvious statement but a very important part of a game none the less.  Measuring fun is not easy and is beyond the scope of this project.  However through some user evaluation and general feedback we will determine the fun factor and do what we can to increase it.

> These user evaluations for this project will take the form of asking both computer science majors and those that are not to participate.  These two groups will again be segregated into those that are told instructions on how to play the game, and those who are just told to figure it out.  A survey will then be done after they play the game to see how much they enjoyed it.  This survey will also tell us of the games usability.

> ## Quick load time ##
> Quick load time is always an important requirement to users.  This is exacerbated by the fact this will be running on a phone.  The user is going to expect the application to launch in a time comparable to other applications.

> There currently is no issue with loading the application.  The issue of textures loading twice has now been solved, and the game loads as fast as any other game.

> ## Graphics ##
> The game should have decent graphics.  This includes some neat special effects (lighting, reflections, and particles).  Not only is this a user requirement, it is a major selling point for any game.

> We will be working on creating textures and graphics that all fit within the theme we are creating with Luminance.  There is a space-age, Tron sort of feel to the game, and the graphics and GUI interfaces reflect that.  The textures are basically complete.  The menus are also in a state of near completion.

> ## Intuitive Input Interface ##
> The input interface should be clean and utilize the perceived affordances people already have for touch screen input usage.  For users who do not enjoy a touch interface we can utilize the pointer and keyboard as well.

> We would also like to make the interface playable regardless of whether the user is holding the phone vertically or horizontally. For this project, this means that the switch from vertical to horizontal must be smooth and not disrupt gameplay.  This currently does not work properly.  The screen turns white and it stays that way.  This is something that is a high priority to fix.

> In order to achieve our goal of a good input interface, we used some open source code from ReplicaIsland to help with this process.  This proved to be very helpful and much of their code has been integrated into our project.

> ## Effective sound effects ##
> The sounds effects in the game should be minimal but effective.  Each important action should carry a unique sound effect.  Since we are on a phone we also need to make sure that without sound the game is still able to convey feedback information.

> We would like these sound effects to be generated by a member of the group, as to best make them fit in with the theme of the game.  They shall also be appropriate to the action they belong to.  For example, placing a mirror could have a chiming sound.

> There are now many very well made sound effects.  This is all thanks to Sten for creating and implementing these things.

> ## Responsive control ##
> The input interface should be very responsive.  There should be a minimal delay (<100ms) of processing the input a user makes and the user noticing the change.

> Specific to our application, there is an issue with the touch input firing off too many events when the screen is touched.  This decreases performance, and therefore makes the application less responsive.  In addition, filtering through touch input events should be very efficient and robust.  It shouldn't take a long time for the program to figure out that the user taps and drags, signifying that the program should scroll.

> This issue, for the most part, has been solved.  Input is really smooth and responsive.  It responds in the way the user expects it to.

> ## Graceful termination on exception ##
> The application if encountering a critical error should attempt a graceful termination.  The users progress in the game should be preserved if possible.

> Upon user evaluation, there were no complaints about this issue. We therefore completed this requirement successfully.

> ## Never crash the phone ##
> The game cannot bring the whole phone down.  This type of error cannot be allowed to persist.  The product will not pass Q&A if there is a way it can crash the phone.

> As well, from the user evaluations, there were no reports of the phone crashing.

> ## Saving and Loading ##
> Users will want to save their progress and load from where they left off.  A puzzle game such as this is expected to be played in small spurts.  The saving and loading process should be transparent.

> At this point, there is no actual saving and loading point.  However, if the phone goes to sleep or leaves the application it will restart at the point the user left it.

> ## Incorrect tool placing handling ##
> We will have to account for when the user accidentally places a tool on the grid that they placed there by mistake, or decide they don't want there at all.  This is accounted for by having an eraser tool to get rid of it.

> In addition to this, we have to account for the user accidentally placing tools on the grid because the way the touch input is handled.  For example, currently tools might be accidentally added to the grid when the user tries to scroll.

> This is an issue that we believe has been solved.  The user can scroll and zoom without accidentally placing a tool on the grid.

> ## Networking ##
> Users might want to upload high scores stored on a server.  The game still needs to be fully operational regardless of network connection.

> For this application, high scores would be in regard to how fast a user completes a level.  This is not something that is currently in place, and will likely be removed from the final deliverable.

> This requirement has since been deprecated.

> ## New tools and mechanics ##
> While we plan to make a complete port of the previous version, we also plan to add new tools and mechanics to make the gameplay even more intriguing.  These tools will be determined by the development team during the next milestone.

> Ideas:
  * Charging station
    * Brings the split up light back into one big beam
    * Depending on the light combo, it may do different things
  * Doors
    * Can be opened by said charging station
  * Fiber Optic cable
    * The user can lay down a cable
    * If the light hits one end, it comes out the other
  * Particle deflector
    * Use to bend light
  * Light Goblin
    * If you wake him up, perhaps he blocks the goal for a slight amount of time

> These are things we would have liked to have implemented, however we simply ran out of time.  We decided that developing a polished, robust game was much more important than adding glorification to a game that was buggy and needed refining.  We hope to continue development after this class in order to make these new features a reality.

# Derived Requirements #
> ## Platform Compatibility ##
> We need to pick a minimum and maximum platform on the Android to support.  Considering availability of Android phones and current proliferation of the Android OS 2.1 and up we have decided to support 2.1 and up.

> This has provided is with quite a few challenges with meeting certain requirements.  For example, when rendering graphics, the older hardware requires us to render them in an obscure way in order to make them work.  In later editions, this would have been much simpler task in a lot of ways.

> ## Portability ##
> The game is being developed for Android using the Android SDK and Java programming language.  Since we are using Java the majority of the code base is already portable.  So we have developed architecture to allow a PC port to be compiled in the future.  This will not be done in this project, however.

> ## Performance ##
> A requirement implied with almost any game.  The game itself should not be a huge drain on the phone.  At all times the game should operate at or above 30 frames per second.

> Specific to our application, there is an issue with the touch input firing off too many events when the screen is touched.  This is an issue because it can cause lag, due to trying to process all of these events.  In addition, there is currently the issue of things being loaded twice as often as they need to be, and being loaded again upon the re-rendering that occurs when the phone is switched from horizontal to vertical, and vice-versa.  This extra loading has caused the phone to freeze altogether at some points.  It is an issue that needs to be fixed if we wish to meet our performance standards.

> ## Memory Usage ##
> With limited memory on the Android sandbox attention must be spent to how much we allocate for the game.  Memory pools and avoiding excessive use of allocations is very important.

> One thing we have been careful about from the start is making sure our use of the 'new' keyword is as limited as possible, and to reuse memory as much as possible.

> We also have to account for this with our texture loading.  We have determined that with OpenGL the textures must have both width and height of a size that is to the power of 2.  While the developers have adhered to this, we have found that these textures are also twice as big as they should be.  We ran out of memory a few times when trying to load the game.  After cutting the size of all the textures in half, we have not run into this problem again.  It has made us more aware of this issue and has led us to be more careful with memory.

> ## Resources ##
> The games assets such as models, sound effects, textures and levels at some point during runtime will live in system memory (RAM).  Care has to be taken to guarantee that only what we need is loaded and that we never go over the sandbox RAM limit.

> ## Game level editor ##
> This is a requirement for the users to be able to design levels for the game.  This currently has taken the back burner in terms of development.  We currently wish to include this in the final project, but polishing the game we currently have is top priority.

> ## Random Level Generator ##
> This is a requirement for the application because it will allow for levels to be dynamically generated for the user.  With this, the user will never run out of levels to play.

> This requirement, however, has been removed from this projects requirements.  As with the new game mechanics, there simply wasn't time to complete it.

> ## Distribution ##
> Distribution of the game is a requirement of interest.  This will require us pushing the game through a quality assurance process.  To succeed in that we need to follow the guidelines set out by Google (http://developer.android.com/guide/index.html).